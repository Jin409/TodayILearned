# 인덱스 구조 및 탐색

## 데이터를 찾는 두가지의 방법

- ex) 홍길동을 찾는다고 가정해보자

1. 모든 반을 돌며 홍길동을 찾는다

- table full scan
- 홍길동 학생이 많은 경우에는 이가 유리하다.

2. 명부를 조회해서 홍길동이 있는 곳만 간다.

- index 사용
- 홍길동 학생이 몇 없는 경우에는 이가 유리하다.

## 인덱스 튜닝의 핵심 요소

1. 인덱스 스캔 과정의 비효율 줄이기

- ex) 시력이 1.0~1.5 인 사람을 찾는다면 시력순으로 정렬해야 보다 빠르게 찾을 수 있다.

2. table 액세스 횟수 줄이기

- ex) 시력이 1.0~1.5 인 홍길동 찾기
- 1.0~1.5 인 사람이 50명이고, 홍길동인 사람이 5명이라면
    - 이름 명부를 보는 것이 더 효율적이다.
    - table 액세스 횟수를 줄일 수 있다.

![graph](https://github.com/Jin409/TodayILearned/assets/77621712/458ae87a-3594-44bf-a537-0a895a0c9bdf)

- 인덱스를 찾아 나가는 것은 수직적 탐색이다.
- 인덱스를 이용해 테이블을 스캔하는 것은 수평적 탐색이다.
    - 여기서 랜덤 액세스가 일어나는데, 이가 I/O 가 일어나므로 가장 성능에 있어 치명적이다.

## SQL 튜닝은 랜덤 I/O 와의 전쟁

- 데이터베이스 성능의 가장 큰 원인은 I/O 이다.
- 인덱스를 사용하면 범위 스캔이 가능하므로 이가 가장 중요한 요소이다.

## 인덱스의 구조

![index](https://github.com/Jin409/TodayILearned/assets/77621712/8526aaec-e7f0-4774-a6e6-e44fa593726f)

- LMC 는 LeftMost Child 의 약자이다.
    - 가장 왼쪽에 위치하는 레코드를 의미한다.
    - 첫번째 레코드보다 작거나 같은 레코드들을 저장한다.
    - ex) 위의 구조에서는 '서' 보다 작거나 같은 레코드들을 저장한다. ex) 김, 강으로 시작하는 이름들..
- 예를 들어 위의 표에서 이재희를 찾는다고 가정해보자.
    1. '이재희'라는 이름은 '서'보다 크거나 같으므로 오른쪽 브랜치 블록으로 이동한다.
    2. 송재훈, 이재룡, 정재우에서 멈춘다. 정재우가 이재희보다 크거나 같기 때문에 바로 이전 레코드인 이재룡을 확인한다.
    3. 이재룡보다 이재희는 크거나 같으므로 이재룡의 하위 블록을 확인한다.
    4. 이재명 다음 이재희로 이동해 내려가다가 이재희보다 큰 이정희에서 멈춘다.
- 리프 블록에는 키값 순으로 정렬되어 있고, 키값이 같으면 ROWID 순으로 정렬되어 있다.

### ROWID 의 구조

- 데이터 블록 주소 + 로우 번호
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
        - 블록 번호 : 데이터 파일 내에서 부여한 상대적인 순번 (파일에서 몇번쨰 조각인지?)
        - 로우 번호 : 블록 내 순번

### 수직적 탐색, 수평적 탐색

- 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 조건에 만족하는 첫번째 레코드를 찾는 것이다.
- 수평적 탐색 : 데이터를 찾는 과정 (ROWID 순으로 확인한다)
    - 인덱스를 만족하는 데이터들을 모두 찾는다.
    - ROWID 를 알아내기 위함이다. -> 데이터의 블록 주소와 로우 번호로 실제 데이터를 찾아낼 수 있다.

## 결합 인덱스 구조

![combined-index](https://github.com/Jin409/TodayILearned/assets/77621712/6d87c6ff-7b66-4b4e-ba40-cb49ff764a47)

- 이번에는 성별 + 이름을 이용해 인덱스를 만들었다.
- 만약, '남자'인 '이재희'를 찾는다고 가정한다면 과정은 다음과 같다.
    1. 루트 블록에서의 '남&최' 보다 '남&이' 가 더 작으므로 LMC 로 이동한다.
    2. LMC 의 블록을 탐색하다가 '남&정재우' 보다 '남&이재희' 가 더 작으므로 하나 이전 레코드인 '남&이재룡'의 하위 브랜치 블록을 확인한다.
    3. '남&이재룡'의 하위 블록에서 탐색하다가, '남&장철수'가 '남&이재희'보다 크므로 여기서 탐색을 종료한다.

### 잘못된 인식

- 구글링을 하다보면, 남자인 이재희를 찾는 과정이 전체 레코드에서 '남자'인 레코드들을 모두 찾은 뒤에 이름이 '이재희'인 레코드들을 모두 찾는다는 것을 볼 수 있다.
- 그러나 이는 잘못된 인식이다.
    - 엑셀과 같이 SQL 은 평면적인 구조가 아니라 B-Tree 구조이기 때문에 이와 같이 탐색하는 것이 더 옳다.

# 인덱스 기본 사용법

## 인덱스를 사용한다는 것

- 우리가 책의 색인에서 원하는 내용을 빠르게 찾을 수 있는 이유는 찾고자 하는 단어들이 서로 모여있기 때문이다
    - ex) 가나다 순으로 ㄱ 에 해당하는 색인들은 모아져 있기에 빠르게 찾을 수 있다.
    - ex) '대한' 이라는 글자를 포함하는 레코드를 모두 찾아라 -> 시작도, 끝도 아니기에 풀스캔을 해야 한다.
- 이렇게 가공되지 않은 인덱스인 경우에만 `Index Range Scan` 을 정상적으로 할 수 있다.

## 인덱스를 Range Scan 할 수 없는 이유

- 인덱스 컬럼을 가공하게 되면 인덱스 스캔 시작점을 찾을 수 없기 때문이다.
- 인덱스를 사용할 때에는 반드시 시작 지점과 끝지점이 존재하게 된다.
    - ex) 2007년 1월에 태어난 사람을 찾는 경우 -> 시작점 : 2007년 1월 1일 / 끝지점 : 2007년 2월 1일 을 만나면 종료
    - ex) 년도에 상관없이 5월에 태어난 사람 -> 풀스캔을 해야 한다. 시작/끝지점을 알 수가 없다.
- 이는 문자열을 LIKE 로 검색할 때에도 동일하게 적용된다.
- OR 조건절인 경우
- IN 조건절인 경우
    - 이도 결국에는 OR 조건절과 비슷한 표현이기에 Range Scan 을 할 수 없다.
    - IN-List Iterator 방식을 사용한다.

## 더 중요한 인덱스 사용 조건

- 인덱스를 Range Scan 하기 위해서는 반드시 `가공하지 않은 인덱스 선두 컬럼이 조건절에` 있어야 한다.
    - 예를 들어, 소속팀 + 사원명 + 연령으로 인덱스를 구성한 경우에 사원명으로 탐색을 하면 인덱스의 효과를 볼 수 없다.
    - 그러나, 인덱스를 기준연도 + 실명 확인 번호로 두고 조건절에 기준연도가 있다면 인덱스의 Range Scan 이 가능하다.

### 인덱스 잘 타니까 튜닝 끝?

- 일일 주문량이 100만건인 커머스에서 주문일자 + 상품번호로 인덱스를 구성했다고 가정해보자

```sql
SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
  AND 상품번호 LIKE '%PING%';

SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
  AND SUBSTR(상품번호, 1, 4) = 'PING';
```

- 첫번째 쿼리는 중간값을 검색하고 있기 때문에 인덱스를 타지 못한다.
- 두번째 쿼리는 컬럼의 값을 가공하고 있기 때문에 인덱스를 타지 못한다.
- 결론적으로 첫번째 조건에 만족하는 주문량인 100만건을 풀스캔하게 된다.

## 인덱스를 이용한 소트 연산 생략

- 데이터가 정렬되어 있기에 Index Range Scan 이 가능한 것이다. 흩어져 있는 경우에는 비효율이 발생한다.
- 만약 인덱스를 장비번호, 변경일자, 변경순번을 조합해서 구성했다고 가정해보자.
    - 이 경우에는 장비번호와 변경일자를 조건절로 조회할 떄 어차피 변경순번 순으로 결과가 나온다.

```sql
SELECT *
FROM 상태변경이력 NHERE 장비번호= 'C'
AND 변경일자= '20180316'
ORDER BY 변경순번
```

- 따라서 변경순번 순으로 정렬을 명령해도 옵티마이저는 이런 경우에 따로 ORDER BY 를 수행하지 않는다.

```sql
SELECT *
FROM 상태변경이력 NHERE 장비번호= 'C'
AND 변경일자= '20180316'
ORDER BY 변경순번
DESC
```

- 만약 위와 같이 역정렬이라면, 인덱스가 RANGE SCAN 을 할 때 거꾸로 수행을 한다.

## ORDER BY 절에서 컬럼 가공

- 보통 조건절에서 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다고 이야기한다. 그러나, SELECT-LIST 에서 컬럼을 가공함으로서 인덱스를 사용할 수 없는 경우도 있다.

```sql
SELECT *
FROM 상태변경이력 NHERE 장비번호= 'C'
AND 변경일자= '20180316'
ORDER BY 변경일자 || 변경순번
```

- 인덱스는 가공한 값으로 정렬을 요청했으나, 가공한 값 기준으로 정렬을 요청했기 때문에 이는 ORDER BY 정렬을 수행하게 된다.

```sql
SELECT *
FROM (SELECT TO_CHAR(A.주문번호, 'FM00000') AS 주문번호, A.업체번호, A.주문금액
      FROM 주문A
      WHERE A.주문일자 = :dt
        AND A.주문번호 〉 NVL(:next_ord_no, 0)
      ORDER BY 주문번호)
WHERE ROWNUM <= 03
```

- 이는 인덱스가 주문일자 + 주문번호라고 가정해보자.
    - 이 쿼리에서는 조건절에서 가공 없이 인덱스의 선두절인 주문일자를 = 로 조회하고 있기에 어차피 주문번호 순으로 출력되기에 정렬을 하지 않아도 되지만, 정렬을 수행한다.
- 이는 ORDER BY 에서의 '주문번호' 는 TO_CHAR 에 의해 가공된 '주문번호'이기 때문이다.

## SELECT-LIST 에서 컬럼 가공

```sql
SELECT MIN(변경순번)
FROM 상태변경이력
WHERE 장비번호 = 'C'
  AND 변경일자 = '20180316'
```

- 인덱스를 `장비번호 + 변경일자 + 변경순번` 으로 구성했다고 가정해보자
- 수직적 탐색을 한 뒤, 수평적 탐색에서 왼쪽으로 내려가 가장 먼저 확인하는 데이터가 장비번호이기 때문에 위와 같이 최소값을 구할 때도 따로 연산을 수행하지 않는다.

```sql
SELECT MAX(변경순번)
FROM 상태변경이력
WHERE 장비번호 = 'C'
  AND 변경일자 = '20180316'
```

- 최대값을 구할 때는 오른쪽으로 내려가서 가장 먼저 확인하는 레코드가 최대값이기 때문에 이 역시도 따로 정렬 연산을 수행하지 않는다.

```sql
SELECT NVL(MAX(TO_NUMBER(변경순번)), 0) -- null 인 경우에는 0을 반환한다
FROM 상태변경이력
WHERE 장비번호 = 'C'
  AND 변경일자 = '20180316'
```

- 위와 같이, 숫자값으로 바꾼 값을 최종으로 반환하기를 원한다면 정렬 연산을 생략할 수 없다.
- 인덱스는 문자열 순인데, 위의 쿼리는 숫자로 바꾼 값을 최종으로 원하기 때문이다.

```sql
SELECT NVL(TO_NUMBER(MAX(변경순번)), 0) -- null 인 경우에는 0을 반환한다
FROM 상태변경이력
WHERE 장비번호 = 'C'
  AND 변경일자 = '20180316'
```

- 그러나 이렇게 순서를 바꾸게 되면, 최대값을 먼저 찾은 뒤에 가공을 하기 때문에 앞선 예시들처럼 정렬 연산 없이 값을 구할 수 있게 된다.

