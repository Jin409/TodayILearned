# 인덱스 구조 및 탐색

## 데이터를 찾는 두가지의 방법

- ex) 홍길동을 찾는다고 가정해보자

1. 모든 반을 돌며 홍길동을 찾는다

- table full scan
- 홍길동 학생이 많은 경우에는 이가 유리하다.

2. 명부를 조회해서 홍길동이 있는 곳만 간다.

- index 사용
- 홍길동 학생이 몇 없는 경우에는 이가 유리하다.

## 인덱스 튜닝의 핵심 요소

1. 인덱스 스캔 과정의 비효율 줄이기

- ex) 시력이 1.0~1.5 인 사람을 찾는다면 시력순으로 정렬해야 보다 빠르게 찾을 수 있다.

2. table 액세스 횟수 줄이기

- ex) 시력이 1.0~1.5 인 홍길동 찾기
- 1.0~1.5 인 사람이 50명이고, 홍길동인 사람이 5명이라면
    - 이름 명부를 보는 것이 더 효율적이다.
    - table 액세스 횟수를 줄일 수 있다.

![graph](https://github.com/Jin409/TodayILearned/assets/77621712/458ae87a-3594-44bf-a537-0a895a0c9bdf)

- 인덱스를 찾아 나가는 것은 수직적 탐색이다.
- 인덱스를 이용해 테이블을 스캔하는 것은 수평적 탐색이다.
    - 여기서 랜덤 액세스가 일어나는데, 이가 I/O 가 일어나므로 가장 성능에 있어 치명적이다.

## SQL 튜닝은 랜덤 I/O 와의 전쟁

- 데이터베이스 성능의 가장 큰 원인은 I/O 이다.
- 인덱스를 사용하면 범위 스캔이 가능하므로 이가 가장 중요한 요소이다.

## 인덱스의 구조

![index](https://github.com/Jin409/TodayILearned/assets/77621712/8526aaec-e7f0-4774-a6e6-e44fa593726f)

- LMC 는 LeftMost Child 의 약자이다.
    - 가장 왼쪽에 위치하는 레코드를 의미한다.
    - 첫번째 레코드보다 작거나 같은 레코드들을 저장한다.
    - ex) 위의 구조에서는 '서' 보다 작거나 같은 레코드들을 저장한다. ex) 김, 강으로 시작하는 이름들..
- 예를 들어 위의 표에서 이재희를 찾는다고 가정해보자.
    1. '이재희'라는 이름은 '서'보다 크거나 같으므로 오른쪽 브랜치 블록으로 이동한다.
    2. 송재훈, 이재룡, 정재우에서 멈춘다. 정재우가 이재희보다 크거나 같기 때문에 바로 이전 레코드인 이재룡을 확인한다.
    3. 이재룡보다 이재희는 크거나 같으므로 이재룡의 하위 블록을 확인한다.
    4. 이재명 다음 이재희로 이동해 내려가다가 이재희보다 큰 이정희에서 멈춘다.
- 리프 블록에는 키값 순으로 정렬되어 있고, 키값이 같으면 ROWID 순으로 정렬되어 있다.

### ROWID 의 구조

- 데이터 블록 주소 + 로우 번호
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
        - 블록 번호 : 데이터 파일 내에서 부여한 상대적인 순번 (파일에서 몇번쨰 조각인지?)
        - 로우 번호 : 블록 내 순번

### 수직적 탐색, 수평적 탐색

- 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 조건에 만족하는 첫번째 레코드를 찾는 것이다.
- 수평적 탐색 : 데이터를 찾는 과정 (ROWID 순으로 확인한다)
    - 인덱스를 만족하는 데이터들을 모두 찾는다.
    - ROWID 를 알아내기 위함이다. -> 데이터의 블록 주소와 로우 번호로 실제 데이터를 찾아낼 수 있다.

## 결합 인덱스 구조

![combined-index](https://github.com/Jin409/TodayILearned/assets/77621712/6d87c6ff-7b66-4b4e-ba40-cb49ff764a47)

- 이번에는 성별 + 이름을 이용해 인덱스를 만들었다.
- 만약, '남자'인 '이재희'를 찾는다고 가정한다면 과정은 다음과 같다.
    1. 루트 블록에서의 '남&최' 보다 '남&이' 가 더 작으므로 LMC 로 이동한다.
    2. LMC 의 블록을 탐색하다가 '남&정재우' 보다 '남&이재희' 가 더 작으므로 하나 이전 레코드인 '남&이재룡'의 하위 브랜치 블록을 확인한다.
    3. '남&이재룡'의 하위 블록에서 탐색하다가, '남&장철수'가 '남&이재희'보다 크므로 여기서 탐색을 종료한다.

### 잘못된 인식

- 구글링을 하다보면, 남자인 이재희를 찾는 과정이 전체 레코드에서 '남자'인 레코드들을 모두 찾은 뒤에 이름이 '이재희'인 레코드들을 모두 찾는다는 것을 볼 수 있다.
- 그러나 이는 잘못된 인식이다.
    - 엑셀과 같이 SQL 은 평면적인 구조가 아니라 B-Tree 구조이기 때문에 이와 같이 탐색하는 것이 더 옳다.


