# 팰린드롬 연결 리스트

- [문제 링크](https://leetcode.com/problems/palindrome-linked-list/)

## 스택을 이용한 풀이

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        Stack<Integer> s = new Stack<>();
        ListNode node = head;
        while (node != null) {
            s.add(node.val);
            node = node.next;
        }

        while (head != null) {
            if (s.pop() != head.val) {
                return false;
            }
            head = head.next;
        }

        return true;
    }
}
```

- head 를 node 로 복사해서 스택에 몯 넣는다.
- 스택은 후입선출이기 떄문에 리스트 노드와 비교하면 자연스레 팰린드롬인지의 여부를 확인할 수 있다.

## 덱을 이용한 풀이

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        Deque<Integer> d = new LinkedList<>();

        while (head != null) {
            d.add(head.val);
            head = head.next;
        }

        while (!d.isEmpty() && d.size() >= 1) {
            if (d.pollFirst() != d.pollLast()) {
                return false;
            }
        }

        return true;
    }
}
```

- deque 는 앞 뒤에서 동시에 뺄 수 있기 때문에 앞 뒤로 빼서 이가 일치하는지 확인한다.

## 세번째 풀이 - 러너를 이용한 풀이

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head, slow = head;

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        if (fast != null) {
            slow = slow.next;
        }

        ListNode rev = null;

        while (slow != null) {
            ListNode next = slow.next;
            slow.next = rev;
            rev = slow;
            slow = next;
        }

        while (rev != null) {
            if (rev.val != head.val) {
                return false;
            }
            rev = rev.next;
            head = head.next;
        }

        return true;
    }
}
```

- 빠른 러너와 느린 러너가 있다.
    - 두 러너는 같은 출발 지점에서 출발
    - 빠른 러너는 두칸씩, 느린 러너는 한칸씩 이동
    - 빠른 러너가 끝까지 갔거나, 끝보다 더 많이 갔을 때 종료를 한다.
    - 만약, LinkedNode 의 개수가 홀수라면 느린 러너는 한칸 더 이동을 해야 한다.
    - 러너들이 모두 이동을 했다면, 느린 러너는 거꾸로 이동을 하면서 역순 연결 리스트인 rev 를 만든다.
        - 이를 head 와 비교한다.
        - deque 에서 한 방향은 앞에서 뒤로, 한 방향은 뒤에서 앞으로 이동하는 것과 동일한 원리이다.