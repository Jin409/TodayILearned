# 헤더의 형태

- field-name:<공백>값

# 헤더의 용도

- HTTP 전송에 필요한 모든 부가 정보
- 필요시에는 임의의 헤더도 추가 가능
- ex) 데이터의 길이 / 압축 정보 등

# 엔티티 헤더

- 엔티티 본문의 데이터를 해석할 수 있는 정보를 제공한다. => 이후 해당 용어가 사라졌다.

# 표현

## Content-Type: 표현 데이터의 형식

- 데이터의 형식
- ex) text/html, application/json

## Content-Encoding: 표현 데이터의 압축 방식

- 데이터 전달 쪽에서 압축 후 인코딩 헤어 추가
- 데이터 읽는 쪽에서 확인하고 압축 해제

## Content-Language: 표현 데이터의 자연 언어

- 표현 데이터의 자연 언어
- ex) ko, en, en-US

## Content-Length: 표현 데이터의 길이

- 바이트 단위

# 협상 (content negotiation)

## Accept

- 클라이언트가 선호하는 미디어 타입의 전달해달라고 서버에 요청하는 것

## Accept-Language 의 적용

![accept-lang](https://github.com/Jin409/TodayILearned/assets/77621712/058c13af-b826-4363-a066-8850e0aad47a)

- 선호하는 언어에 대해서 제공하게 되면, 서버쪽에서 이에 대해 응답할 수 있다.

![example](https://github.com/Jin409/TodayILearned/assets/77621712/d932fcee-e958-45cd-9204-8bc70cc3f30b)

- 만약 위처럼, 한국어를 요청했는데 이가 지원이 안되는 경우에는 영어를 보내도록 하려면 어떻게 해야 할까?

## Quality Values

```
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
```

### 우선순위 1

- 0~1
- 클수록 높은 우선순위
- 생략된 경우는 1
- 위처럼 클라이언트 쪽에서 선호하는 우선순위를 보낸다면, 응답하는 서버쪽에서 이를 참고하여 응답할 수 있다.

### 우선순위2

- 구체적인 것이 우선한다.

```
Accept: text/*, text/plain, text/plain;format=flowed, */*
```

- ex) text/plain;format=flowed 이 가장 구체적이므로 우선되고, 다음으로 text/plain 이 우선된다.

# 전송 방식

## 단순 전송

```
Content-Length: 3423
```

- 길이를 명확히 지정한다.

## 압축 전송

```
Content-Encoding: gzip
```

## 분할 전송

```
Content-Encoding: chunked
```

- 바이트 단위로 나눠서 보낸다.
    - 서버에서 5바이트가 완성되면 보내고, 이후에 5바이트가 또 다시 완성되면 보낸다.
- 끝난 뒤에는 0과 \r\n 을 보낸다.

### 주의할 점

- Content-Length 를 보내면 안된다.
- 알 수 없기 때문에.

## 범위 전송

- 중간에 연결이 끊겼을 경우, 처음부터 다시 보내달라고 요청하는 것이 아니라 범위에 맞게 요청한다.

# 일반 정보

## From

- 유저 에이전트의 이메일 정보

## Referer

- 이전 웹 사이트의 주소
- 현재 요청된 페이지의 이전 주소
- ex) 구글에 검색한 뒤 특정 링크에 들어가면 어떤 링크를 통해 들어왔는지 확인할 수 있다.

## User-Agent

- 웹 브라우저의 정보
- 클라이언트의 애플리케이션의 정보

## Server

- 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보

## Date

- 메시지가 발생한 날짜와 시간

# 특별한 정보들

## Host

- 요청한 호스트의 정보
- 필수값
- 하나의 서버가 여러 도메인을 처리해야 할 때
