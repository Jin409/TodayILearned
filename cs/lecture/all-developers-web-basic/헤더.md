- [헤더의 형태](#헤더의-형태)
- [헤더의 용도](#헤더의-용도)
- [엔티티 헤더 => 표현 헤더](#엔티티-헤더---표현-헤더)
- [표현](#표현-헤더)
    * [Content-Type: 표현 데이터의 형식](#content-type--표현-데이터의-형식)
    * [Content-Encoding: 표현 데이터의 압축 방식](#content-encoding--표현-데이터의-압축-방식)
    * [Content-Language: 표현 데이터의 자연 언어](#content-language--표현-데이터의-자연-언어)
    * [Content-Length: 표현 데이터의 길이](#content-length--표현-데이터의-길이)
- [협상 (content negotiation)](#협상-헤더--content-negotiation-)
    * [Accept](#accept)
    * [Accept-Language 의 적용](#accept-language-의-적용)
    * [Quality Values](#quality-values)
        + [우선순위 1](#우선순위-1)
        + [우선순위2](#우선순위2)
- [전송 방식](#전송-방식)
    * [단순 전송](#단순-전송)
    * [압축 전송](#압축-전송)
    * [분할 전송](#분할-전송)
        + [주의할 점](#주의할-점)
    * [범위 전송](#범위-전송)
- [일반 정보](#일반-정보)
    * [From](#from)
    * [Referer](#referer)
    * [User-Agent](#user-agent)
    * [Server](#server)
    * [Date](#date)
- [특별한 정보들](#특별한-정보들)
    * [Host](#host)

# 헤더의 형태

- field-name:<공백>값

# 헤더의 용도

- HTTP 전송에 필요한 모든 부가 정보
- 필요시에는 임의의 헤더도 추가 가능
- ex) 데이터의 길이 / 압축 정보 등

# 엔티티 헤더 => 표현 헤더

- 엔티티 본문의 데이터를 해석할 수 있는 정보를 제공한다. => 이후 해당 용어가 사라졌다.
- 이는 추후에 표현이라는 말로 변했다.
    - 표현은 표현에 필요한 메타 데이터 + 표현 데이터의 합이다.
- 표현의 데이터는 페이로드라고 하기도 한다.

# 표현 헤더

## Content-Type: 표현 데이터의 형식

- 데이터의 형식
- ex) text/html, application/json, image/png

## Content-Encoding: 표현 데이터의 압축 방식

- 데이터 전달 쪽에서 압축 후 인코딩 헤어 추가
- 데이터 읽는 쪽에서 확인하고 압축 해제
- ex) gzip, identity(압축하지 않음)

## Content-Language: 표현 데이터의 자연 언어

- 표현 데이터의 자연 언어
- ex) ko, en, en-US

## Content-Length: 표현 데이터의 길이

- 바이트 단위

# 협상 헤더 (content negotiation)

- 클라이언트가 선호하는 표현을 요청하는 것

## Accept

- 클라이언트가 선호하는 미디어 타입의 전달해달라고 서버에 요청하는 것

## Accept-Language 의 적용

![accept-lang](https://github.com/Jin409/TodayILearned/assets/77621712/058c13af-b826-4363-a066-8850e0aad47a)

- 선호하는 언어에 대해서 제공하게 되면, 서버쪽에서 이에 대해 응답할 수 있다.

![example](https://github.com/Jin409/TodayILearned/assets/77621712/d932fcee-e958-45cd-9204-8bc70cc3f30b)

- 만약 위처럼, 한국어를 요청했는데 이가 지원이 안되는 경우에는 영어를 보내도록 하려면 어떻게 해야 할까?

## Quality Values

```
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
```

### 우선순위 1

- 0~1
- 클수록 높은 우선순위
- 생략된 경우는 1
- 위처럼 클라이언트 쪽에서 선호하는 우선순위를 보낸다면, 응답하는 서버쪽에서 이를 참고하여 응답할 수 있다.

### 우선순위2

- 구체적인 것이 우선한다.

```
Accept: text/*, text/plain, text/plain;format=flowed, */*
```

- ex) text/plain;format=flowed 이 가장 구체적이므로 우선되고, 다음으로 text/plain 이 우선된다.

# 전송 방식

## 단순 전송

```
Content-Length: 3423
```

- 길이를 명확히 지정한다.

## 압축 전송

```
Content-Encoding: gzip
```

## 분할 전송

```
Content-Encoding: chunked
```

- 바이트 단위로 나눠서 보낸다.
    - 서버에서 5바이트가 완성되면 보내고, 이후에 5바이트가 또 다시 완성되면 보낸다.
- 끝난 뒤에는 0과 \r\n 을 보낸다.

### 주의할 점

- Content-Length 를 보내면 안된다.
- 알 수 없기 때문에.

## 범위 전송

- 중간에 연결이 끊겼을 경우, 처음부터 다시 보내달라고 요청하는 것이 아니라 범위에 맞게 요청한다.

# 일반 정보

## From

- 유저 에이전트의 이메일 정보

## Referer

- 이전 웹 사이트의 주소
- 현재 요청된 페이지의 이전 주소
- ex) 구글에 검색한 뒤 특정 링크에 들어가면 어떤 링크를 통해 들어왔는지 확인할 수 있다.

## User-Agent

- 웹 브라우저의 정보
    - 어떤 종류의 브라우저에서 장애가 발생하는지 파악할 수 있다.
- 클라이언트의 애플리케이션의 정보

## Server 헤더

- 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
    - 여러 서버를 거친 끝에 요청을 처리해주는 서버가 ORIGIN 서버

## Date

- 메시지가 발생한 날짜와 시간
- 응답에서만 사용한다.

# 특별한 정보들

## Host

- 요청한 호스트의 정보
- 필수값
- 하나의 서버가 여러 도메인을 갖고있을 수 있다.

## Location

- 3xx 의 응답인 경우, 해당 위치로 자동 리다이렉트 한다.
- 201 의 응답인 경우, 생성된 리소스의 URI 를 명시한다.

## Allow

- 허용하는 http method 만 표기한다.

## Retry-After

- 503 은 서비스가 언제까지 불능인지 알려줄 수 있다.

# 인증 헤더

## Authorization

- 클라이언트의 인증 정보를 서버에 전달한다.

## WWW-Authenticate

- 리소스 접근시 필요한 인증 방법을 정의한다.
- 인증을 하기 위해서는 어떻게 해야 하는지 명시한다.

# 쿠키

## Set-Cookie

- 서버에서 클라이언트로 쿠키 전달

## Cookie

- 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달한다.

![쿠키-사용](https://github.com/Jin409/TodayILearned/assets/77621712/05e07fd8-ffcd-48ab-8fe9-f3e0e85c6153)

- 서버가 사용자가 로그인 시에 사용자의 정보를 쿠키에 넣어서 반환한다.
- 클라이언트는 쿠키 저장소에 이를 저장해둔다.
    - 이후 웹 브라우저는 쿠키를 꺼내서 헤더를 만들어서 유저의 정보를 전달한다.

## 쿠키 미사용시

- 모든 요청에 쿼리 파라미터나 쿼리 스트링에 사용자 정보가 포함되도록 해야 한다.
    - 이는 보안적 / 개발적으로 문제가 있다.

## 쿠키의 주된 용도

- 사용자 로그인 세션 관리
    - 직접적으로 쿠키에 사용자의 정보 (ex) 이름은 홍길동) 를 담아서 반환하는 것은 위험.
    - 이로 인해 세션을 반환한다.
- 광고 정보 트래킹 시

## 쿠키는 항상 서버에 전송된다.

- 네트워크 트래픽을 추가 유발한다.
    - 클라이언트와 서버 각각의 HTTP 요청에 포함되기 떄문이다.
- 최소한의 정보만
    - ex) 세션, id 인증 토큰
- 서버에 전송하지 않고 웹 브라우저 내부에만 데이터를 저장하고 싶다면 클라이언트 측에서 웹 스토리지를 활용하면 된다.

## 생명 주기

- Set-Cookie: expires 라는 옵션을 넣을 수 있다.
    - 이후에는 자동으로 만료된다.
- max-age : 0이나 음수를 지정하면 쿠키가 삭제된다.
- 세션 쿠키 : 만료 날짜를 입력하면 브라우저 종료시 까지만 유지된다.
- 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지한다.

## 도메인

- 쿠키에 도메인을 지정할 수 있다.
- domain=example.org 로 하면, 명시한 도메인과 서브 도메인을 포함해서 모두 전송하게 된다.
- 도메인을 생략하면, example.org 에서만 (쿠키가 생성된 도메인에서만) 쿠키에 접근할 수 있고, 서브 도메인들은 접근할 수 없다.

## 경로

- 경로를 포함한 하위 경로 페이지만 쿠키가 접근할 수 있다.
- path=/ 경로로 지정한다.

## 보안

### Secure

- https 인 경우에만 클라이언트에서 서버로 전송된다.

### HttpOnly

- 자바스크립트에서 접근 불가
- HTTP 전송에만 활용한다.

### SameSite

- 내가 요청하는 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송할 수 있다.