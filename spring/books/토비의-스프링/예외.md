# 사라진 SQLException

```java
public void deleteAll() throws SQLException {
    this.jdbcContext.executeSql("delete from users");
} 
```

```java
public void deleteAll() throws SQLException {
    this.jdbcTemplate.executeSql("delete from users");
} 
```

- JdbcContext 에서 스프링에 내장된 JdbcTemplate 을 사용하게 되면서 예외 처리 부분이 사라졌다.

## 초난감 예외처리

### 예외 블랙홀

```java
public void example() {
    try {
        // .. do something
    } catch (Exception e) {
        // 아무것도 하지 않는다
    }
}
```

- 예외가 발생하면, 이를 아무것도 하지 않고 넘어가게 되는 것은 위험하다.
    - 어디선가 오류가 발생하게 되어도 무시하고 계속 진행하기 때문이다.
- printStackTrace 만 하고 넘어가는 것도 큰 문제가 발생할 수 있다.

### 무의미하고 무책임한 throws

```java
public void method1() throws Exception {
    method2();
}

public void method2() throws Exception {

}
```

- 이런 식으로 계속해서 메소드 호출마다 Exception 을 기계적으로 떠넘기는 것도 문제가 된다.
- 이렇게 되면, throws Exception 이 선언되어 있다고 하더라도 이가 어떤 의미 있는 정보를 주지 못한다.

## 예외의 종류와 특징

- 가장 중요한 것은 예외를 다루는 방법이다.

### Error

`java.lang.Error` 클래스의 서브클래스들

- 비정상적인 상황이 발생했을 경우에 사용된다.
- VM 에서 주로 발생하고, 애플리케이션 코드 단위에서 잡으려고 하면 안된다.
    - 잡아봤자, 대응 방법이 없다.
- 이것에 대한 에러 대응은 신경쓰지 않아도 된다.

### Exception 과 체크 예외

- 코드의 작업 중에 예외상황이 발생한 경우에 사용된다.
- Checked Exception
    - Exception 클래스의 서브 클래스
    - RuntimeException 클래스를 상속하지 않은 것들
    - `일반적으로 이야기하는 예외`
    - 반드시 catch 문으로 잡던가 다시 throws 를 해야 한다
- Unchecked Exception
    - Exception 클래스의 서브 클래스
    - RuntimeException 클래스를 상속한 것들

- RuntimeException 과 언체크/런타임 예외
    - RuntimeException 클래스를 상속한 예외들은 `명시적인 예외처리를 강제하지 않기 때문에 UncheckedException` 이라고 불린다.
    - 런타임 예외라고도 한다
    - catch 문으로 잡거나 throws 로 선언하지 않아도 된다.
    - 이는 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 예외이다.
        - ex) IllegalArgumentException, NullPointerException

## 예외처리 방법

### 예외 복구

- 예외 상황을 파악하고 정상 상태로 돌려놓는 것
    - ex) 사용자가 접근하고자 하는 파일이 존재하지 않을 때 상황에 대해 안내하고, 다른 파일로 접근을 유도하는 것
- 체크 예외들은 이렇게 복구 가능성이 있는 경우에 사용한다.
    - API 를 사용하는 개발자가 예외 상황이 발생할 수 있다는 것을 인식할 수 있도록 도와주고 적절한 처리에 대한 시도를 요구한다.

### 예외처리 회피

- 자신을 호출한 쪽으로 예외처리를 던져버리는 것이다.
    1. throws 로 알아서 던져지게 한다.
    2. catch 로 예외를 잡은 뒤 로그를 남기고 다시 던진다.
- 회피 역시도 복구와 같이 의도가 분명해야 한다.
    - ex) DAO 에서 발생한 SQLException 을 서비스 계층으로 던져버리게 된다면?

### 예외 전환

- 예외를 복구해서 정상적인 상태로는 만들 수 없는 경우 예외를 메소드 밖으로 던져버린다.
- 발생한 예외를 `그대로 넘기는 것이 아니라 적절한 예외로 전환해서 던진다`

- 목적

1. 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서

- ex) 중복 아이디를 등록하려고 하는 경우, SQLException 을 DuplicateUserIdException 과 같은 예외로 던진다.
- `중첩 예외`로 만드는 것이 좋다.
- 아래와 같이 initCause() 메소드로 근본 원인이 되는 예외를 넣어주면 된다.

```java
public class Example {
    public void example() {
        try {
            //.. something
        } catch (Exception e) {
            throw DuplicateUserIdException().initCause(e);
        }
    }
}
```

2. 예외를 처리하기 쉽고 단순하게 만들기 위해서 포장한다.

- 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 것은 똑같다.
    - 앞선 목적과 다르게 주로 체크 예외를 언체크 예외로 바꾸는 경우를 이야기한다.

```java
public class Example {
    public void example() {
        try {
            // .. do something
        } catch (NamingException ne) {
            throw new EJBException(ne);
        }
    }
}
```

- EJBException 은 런타임 예외이다.
    - 이렇게 런타임 예외로 만들어서 전달하면 EJB 는 이를 시스템 익셉션으로 인식하고 트랜잭션을 자동으로 롤백해준다.

### 복구하지 못할 예외라면

- 코드에서는 런타임 예외로 포장해서 던져버린다.
    - 어차피 해결이 안되니 회피해버린다.
- 예외처리 서비스 등을 이용해 자세한 로그를 남긴다.
- 관리자에게 메일 등으로 통보한다.
- 사용자에게는 친절한 안내 메시지를 보여준다.

## 예외처리 전략

### 런타임 예외의 보편화

- 과거 독립형 애플리케이션에서는 시스템 예외라고 해도, 작업이 중단되지 않게 하고 복구해야 했다.
    - 그러나, 자바의 경우에는 수많은 사용자가 동시에 요청을 보내고 각 요청을 독립적으로 취급한다.
    - 하나의 요청을 처리하는 중에 예외가 발생하면 해당 작업만 중지시키면 된다.
- 대응이 불가능한 체크 예외인 경우 빨리 런타임 예외로 전환해서 던지는 게 낫다
- 최근 스펙에서는 언체크 예외로 정의하는 것이 일반화되고 있다.

### add() 메소드의 예외처리

- SQLException 은 대부분 복구 불가능한 예외이다. 따라서 잡아봤자 처리할 수도 없고, 계속 throws 로 전달되다가는 애플리케이션 밖으로 던져진다.
    - 이보다는 차라리 런타임 예외로 포장하여 다른 메소드들이 신경쓰지 않도록 하는 편이 낫다.

```java
public class DuplicateUserIdException extends RuntimeException {
    public DuplicateUserIdException(Throwable cause) {
        super(cause);
    }
}
```

```java
public void add() throws DuplicateUserIdException {
    try {
        // JDBC 를 이용해 user 정보를 DB 에 추가하는 코드
        // SQLException 을 던지는 메소드를 호출하는 코드
    } catch (SQLException e) {
        if (e.getErrorCode() == MySqlErrorNumbers.ER_DUP_ENTRY) {
            throw new DuplicateUserIdException(e); // 런타임 예외로 전환
        } else {
            throw new RuntimeException(e); // 예외 포장
        }
    }
}
```

- throws 가 아닌 런타임 예외로 전환해서 던지도록 한다.
- 만약 중복된 사용자로 인한 오류라면 DuplicateUserIdException 를 던진다.
    - 이로 인한 오류가 아니라면 그냥 RuntimeException 을 던진다.

### 애플리케이션 예외

- 애플리케이션 로직 자체에 의해 의도적으로 발생시키고, 반드시 조치를 취할 것을 요구하는 예외
    - ex) 잔고가 모자란 상황에서 출금을 요청하는 경우
- 설계 방법
    1. 정상적 / 잔고 부족 시의 리턴 값을 다르게

    - 이 리턴 값을 결과 상태에 대한 정보로 활용한다.
    - ex) 잔고가 부족하면 -1, 다른 상황에는 요청 금액을 리턴
    - 단점
        - 표준이 존재하지 않기 때문에 코드화 및 관리가 제대로 이루어지지 않으면 혼란
        - 결과 값을 확인하는 조건문이 자주 등장해야 하는 것

    2. 예외 상황에서는 비지니스적인 의미를 띤 예외를 던지도록 한다.

    - 잔고가 부족하다면 InsufficientBalanceException 을 던진다
    - catch 블록에 예외상황에 대한 처리를 모아두면 된다.
    - 의도적으로 이를 체크 예외로 만든다.
        - 잊지 않고 예외 상황에 대한 로직을 구현하도록 강제해줘야 한다.


