# 템플릿이란

- 바뀌는 성질이 다른 코드 중, 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 부분을 자유롭게 변경되는 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 것

# 다시 보는 초난감 DAO

## 예외처리 기능을 갖춘 DAO

- JDBC 코드에서는 반드시 중간에 예외가 발생하더라도 리소스를 반환하도록 만들어야 한다.

### JDBC 수정 기능의 예외 처리 코드

- 리소스를 반환하기 전에 예외가 발생하면 메소드 실행을 끝내지 못하고 메소드를 빠져나가게 된다.
    - close() 메서드가 실행되지 않아서 제대로 리소스가 반환되지 않는다.

- 서버에서는 일반적으로 DB 에 커넥션의 개수를 제한하여 관리한다.
    - 명시적으로 close() 를 호출해 돌려줘야지만 재사용이 가능하기에 이는 중요하다.

- try / catch / finally 구문으로 처리할 수 있다.
    - 그러나 리소스가 null 일수도 있기에 분기하여 처리해야 한다.

```java
public class UserDao {
    public void add(User user) {
        try {
            c = dataSource.getConnection();

            ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getPassword());

            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) { // ps 를 얻었는지 아닌지 알 수 없기 떄문에
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
}
```

# 변하는 것과 변하지 않는 것

## JDBC try/catch/finally 코드의 문제점

- 매번 try/catch/finally 를 이용해서 코드를 작성해야 한다면, 놓치는 부분이 생길 수도 있다.

## 분리와 재사용을 위한 디자인 패턴 적용

- 변하는 성격이 다른 것을 찾아내야 한다.

```java
 public void deleteAll() throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;
    try {
        c = dataSource.getConnection();
        ps = c.prepareStatement("delete from users"); // 변하는 부분
        ps.executeUpdate();
    } catch (SQLException e) {
        throw e;
    } finally {
        if (ps != null) {
            try {
                ps.close();
            } catch (SQLException e) {
            }
        }
        if (c != null) {
            try {
                c.close();
            } catch (SQLException e) {
            }
        }
    }
}
```

- 위의 표기된 변하는 부분 이외에는 잘 변하지 않는다.
- 변하지 않는 부분을 나머지에서 분리하면 된다.

### 메소드 추출

```java
 import java.sql.PreparedStatement;
import java.sql.SQLException;

public void deleteAll() throws SQLException {
    //..
    try {
        c = dataSource.getConnection();
        ps = makeStatement(c);
        ps.executeUpdate();
    } catch (SQLException e) {
        throw e;
    }
    // ..
}

public PreparedStatement makeStatement(Connection c) throws SQLException {
    PreparedStatement ps;
    ps = c.prepareStatement("delete from users");
    return ps;
}
```

- 변하는 부분을 메소드로 뺀다
- 그러나 이는 별다른 소득이 없다.
    - 메서드가 재사용되지 않는다.
    - DAO 로직마다 새롭게 만들어야 하기 떄문이다.

### 템플릿 메서드 패턴의 적용

- 상속을 통해 기능을 확장해서 사용한다.
- 변하지 않는 부분은 슈퍼 클래스
- 변하는 부분은 추상 메서드로 정의
    - 서브 클래스에서 오버라이드하여 쓰도록 한다.

```java
import java.sql.PreparedStatement;

public class UserDeleteAll extends UserDao {
    protected PreparedStatement makeStatement(Connection c) throws SQLException {
        ps = c.prepareStatement("delete from users");
        return ps;
    }
}
```

- 장점
    - 상속을 통해 자유롭게 확장할 수 있다.
- 단점
    - DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.
    - 클래스를 설계하는 시점에서 이미 확장구조가 고정되어 버린다.

### 전략 패턴의 적용

오브젝트를 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 한다.<br>
확장에 해당하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다.

![전략-패턴](https://github.com/Jin409/TIL/assets/77621712/3e2b0f60-1313-4ebd-a6dd-7e661191d498)

- Context 의 contextMethod() 에서 일정 구조를 갖고 동작한다.
    - deleteAll() 에서 변하지 않는 부분을 의미한다.
- Strategy 인터페이스를 통해서 특정 확장 기능을 위임한다.

```java
import java.sql.SQLException;

public void deleteAll() throws SQLException {
    try {
        c = dataSource.getConnection();

        StatementStrategy strategy = new DeleteAllStatement();
        ps = strategy.makePreparedStatement(c);

        ps.executeUpdate();
    } catch (SQLException e) {
        // .. 
    }
}
```

- 전략 패턴은 필요에 따라 컨텍스트는 유지하되, 전략을 바꿔서 쓰는 것이다.
    - ex) contextMethod() 는 유지하지만, strategy 를 바꿔서 쓴다.
    - 그러나 위의 코드를 보면 알 수 있듯, 구체 전략 클래스가 지정되어 있기에 OCP 원칙에 위배된다.

### DI 적용을 위한 클라이언트 / 컨텍스트 분리

![ci](https://github.com/Jin409/TodayILearned/assets/77621712/16dbc96c-d285-4002-8501-76fe168e1b12)

- Context 가 아닌 Client 가 어떤 전략을 사용할지 결정하도록 해야 한다.
