# 템플릿이란

- 바뀌는 성질이 다른 코드 중, 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 부분을 자유롭게 변경되는 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 것

# 다시 보는 초난감 DAO

## 예외처리 기능을 갖춘 DAO

- JDBC 코드에서는 반드시 중간에 예외가 발생하더라도 리소스를 반환하도록 만들어야 한다.

### JDBC 수정 기능의 예외 처리 코드

- 리소스를 반환하기 전에 예외가 발생하면 메소드 실행을 끝내지 못하고 메소드를 빠져나가게 된다.
    - close() 메서드가 실행되지 않아서 제대로 리소스가 반환되지 않는다.

- 서버에서는 일반적으로 DB 에 커넥션의 개수를 제한하여 관리한다.
    - 명시적으로 close() 를 호출해 돌려줘야지만 재사용이 가능하기에 이는 중요하다.

- try / catch / finally 구문으로 처리할 수 있다.
    - 그러나 리소스가 null 일수도 있기에 분기하여 처리해야 한다.

```java
public class UserDao {
    public void add(User user) {
        try {
            c = dataSource.getConnection();

            ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getPassword());

            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) { // ps 를 얻었는지 아닌지 알 수 없기 떄문에
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
}
```

# 변하는 것과 변하지 않는 것

## JDBC try/catch/finally 코드의 문제점

- 매번 try/catch/finally 를 이용해서 코드를 작성해야 한다면, 놓치는 부분이 생길 수도 있다.

## 분리와 재사용을 위한 디자인 패턴 적용

- 변하는 성격이 다른 것을 찾아내야 한다.

```java
 public void deleteAll() throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;
    try {
        c = dataSource.getConnection();
        ps = c.prepareStatement("delete from users"); // 변하는 부분
        ps.executeUpdate();
    } catch (SQLException e) {
        throw e;
    } finally {
        if (ps != null) {
            try {
                ps.close();
            } catch (SQLException e) {
            }
        }
        if (c != null) {
            try {
                c.close();
            } catch (SQLException e) {
            }
        }
    }
}
```

- 위의 표기된 변하는 부분 이외에는 잘 변하지 않는다.
- 변하지 않는 부분을 나머지에서 분리하면 된다.

### 메소드 추출

```java
 import java.sql.PreparedStatement;
import java.sql.SQLException;

public void deleteAll() throws SQLException {
    //..
    try {
        c = dataSource.getConnection();
        ps = makeStatement(c);
        ps.executeUpdate();
    } catch (SQLException e) {
        throw e;
    }
    // ..
}

public PreparedStatement makeStatement(Connection c) throws SQLException {
    PreparedStatement ps;
    ps = c.prepareStatement("delete from users");
    return ps;
}
```

- 변하는 부분을 메소드로 뺀다
- 그러나 이는 별다른 소득이 없다.
    - 메서드가 재사용되지 않는다.
    - DAO 로직마다 새롭게 만들어야 하기 떄문이다.

### 템플릿 메서드 패턴의 적용

- 상속을 통해 기능을 확장해서 사용한다.
- 변하지 않는 부분은 슈퍼 클래스
- 변하는 부분은 추상 메서드로 정의
    - 서브 클래스에서 오버라이드하여 쓰도록 한다.

```java
import java.sql.PreparedStatement;

public class UserDeleteAll extends UserDao {
    protected PreparedStatement makeStatement(Connection c) throws SQLException {
        ps = c.prepareStatement("delete from users");
        return ps;
    }
}
```

- 장점
    - 상속을 통해 자유롭게 확장할 수 있다.
- 단점
    - DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.
    - 클래스를 설계하는 시점에서 이미 확장구조가 고정되어 버린다.

### 전략 패턴의 적용

오브젝트를 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 한다.<br>
확장에 해당하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다.

![전략-패턴](https://github.com/Jin409/TIL/assets/77621712/3e2b0f60-1313-4ebd-a6dd-7e661191d498)

- Context 의 contextMethod() 에서 일정 구조를 갖고 동작한다.
    - deleteAll() 에서 변하지 않는 부분을 의미한다.
- Strategy 인터페이스를 통해서 특정 확장 기능을 위임한다.

```java
public interface StatementStrategy { // 전략
    PreparedStatement makePrearedStatement(Connection c) throws SQLException;
}

public class DeleteAllStatement implements StatementStrategy { // 전략의 구현
    @Override
    public PreparedStatement makePrearedStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("delete from users");
        return ps;
    }
}

public void deleteAll() throws SQLException { // context
      ...
    try {
        c = dataSource.getConnection();

        StatementStrategy strategy = new DeleteAllStatement(); // 구체 전략 클래스가 지정되어 있다.
        ps = strategy.makePrearedStatement(c);

        ps.executeUpdate();
    } catch (SQLException e) {
      ...

```

- 전략 패턴은 필요에 따라 컨텍스트는 유지하되, 전략을 바꿔서 쓰는 것이다.
    - ex) contextMethod() 는 유지하지만, strategy 를 바꿔서 쓴다.
    - 그러나 위의 코드를 보면 알 수 있듯, 구체 전략 클래스가 지정되어 있기에 OCP 원칙에 위배된다.

### DI 적용을 위한 클라이언트 / 컨텍스트 분리

![ci](https://github.com/Jin409/TodayILearned/assets/77621712/16dbc96c-d285-4002-8501-76fe168e1b12)

- Context 가 아닌 클라이언트가 어떤 전략을 사용할지 결정하도록 해야 한다.
- 현재 deleteAll() 메서드의 경우에는, 직접 클라이언트 코드인 StatementStrategy 를 만드는 코드를 포함하고 있다.
    - 나머지 코드는 컨텍스트 코드이기 때문에 분리해야 한다.

```java
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = dataSource.getConnection();

        ps = stmt.makePrearedStatement(c);

        ps.executeUpdate();
        //....
    }
```

- 클라이언트가 어떤 전략을 선택할지 결정해야 하기 때문에 context 의 경우에는 파라미터로 이를 넘겨 받는다.
    - 어떤 전략이 들어올지 모르기에, 인터페이스로 파라미터를 선언한다.
- 이렇게 컨텍스트를 분리하면, deleteAll() 메서드가 클라이언트가 된다.

```java
public class UserDao { // 클라이언트! 어떤 전략을 사용할지 선택한다.
    public void deleteAll() {
        StatementStrategy st = new DeleteAllStatement(); // 선택한 전략 오브젝트의 생성
        jdbcContextWithStatementStrategy(st); // 선택한 전략 오브젝트 전달 및 컨텍스트 호출
    }
}
```

# JDBC 전략 패턴의 최적화

## 전략과 클라이언트의 동거

지금까지 작성해온 코드의 문제점들

- 문제점1. DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다.
    - 클래스 파일의 개수가 늘어난다.
- 문제점2. 전달 받아야 할 부가적인 정보가 있는 경우, 오브젝트를 전달받는 생성자와 저장해둘 변수를 만들어야 하는 것

### 로컬 클래스

- 문제점1에 대한 해결 방법
    - 구현 클래스의 개수를 줄일 수 있다.
- UserDao 클래스 안에 내부 클래스로 정의해버리는 것
    - 어차피 로직이 UserDao 의 밖에서는 사용되지 않기 때문이다.

```java
import java.sql.PreparedStatement;

public class UserDao {
    class AddStatement implements StatementStrategy {
        public PreparedStatement makePreparedStatement(Connection c) {

        }
    }
}
```

- 내부 클래스이기 때문에 선언된 곳의 정보에 접근할 수 있게 된다.
    - 이전의 방식이라면, add 메서드에 User 필드를 생성하고 이를 생성자로 선언해줘야 했을 것이다.

즉, 내부 클래스를 이용하면 생성자와 인스턴스 변수를 제거할 수 있기 때문에 간결해진다.

- 바꾸기 전의 코드

```java
public class UserDao {
    public void add(User user) throws SQLException {
        StatementStrategy st = new AddStatement(user); // 이렇게! 파라미터로 유저의 정보를 넘겨야 했다.
        jdbcContextWithStatementStrategy(st);
    }
}
```

- 바꾸고 나서의 코드

```java
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class UserDao {
    class AddStatement implements StatementStrategy {
        public void add(final User user) throws SQLException {
            class AddStatement implements StatementStrategy {
                public PreparedStatement makePreparedStatement(Connection c) {
                    PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
                    ps.setString(1, user.getId());
                    ps.setString(2, user.getName());
                    ps.setString(3, user.getPassword());
                    return ps;
                }
            }

            StatementStrategy st = new AddStatement(); // 파라미터로 user 를 전달하지 않아도 된다.
            // 위에서 명시한 이중 클래스를 생성한다.
        }
    }

}
```

- 로컬 변수를 가져다가 바로 쓸 수 있다는 것이 큰 장점이다.

### 익명 내부 클래스

- 이름조차도 굳이 명시하지 않아도 된다.

```java
import java.sql.PreparedStatement;

public class UserDao {
    public void add() {
        StatementStrategy st = new StatementStrategy() { // 선언했던 인터페이스를 구현
            public PreparedStatement makePreparedStatement(Connection c) {
                PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
                // .. 중략
            }
        }
    }
}
```

# 컨텍스트와 DI

## JdbcContext 의 분리

- 이전의 코드들을 다시 보자.
    - 전략 : 익명 내부 클래스
    - 클라이언트 : UserDao 내부의 메서드
    - 컨텍스트 : jdbcContextWithStatementStrategy()
        - 여기서 컨텍스트는 다른 DAO 에서도 사용할 수 있도록 해야 한다.

## 클래스 분리

컨텍스트를 분리하여 JdbcContext 라는 클래스에 넣어보자.

```java
public class JdbcContext {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public workWithStatementStrategy(StatementStrategy stmt) {
        // .. 중략l
    }
}
```

- JdbcContext 클래스 안으로 옮겼다.
- UserDao 에도 JdbcContext 를 DI 로 받을 수 있도록 한다.
    - 필드를 추가하고, setter 로 세팅한다.

### 빈 의존관계 변경

- 스프링의 DI 는 인터페이스를 사이에 두고 의존 클래스로 바꿔서 사용한다.
    - 그러나, JdbcContext 의 경우에는 굳이 구체 클래스가 바뀔 이유가 없기 때문에 인터페이스를 사이에 두지 않는다.
- 스프링의 빈 설정은 클래스 레벨이 아닌, 런타임 시에 만들어지는 오브젝트 레벨의 의존관계에 따라 정의된다.
  ![img](https://github.com/Jin409/TodayILearned/assets/77621712/4dfa7ca5-c4e2-44cb-acd1-0e74153a463f)

