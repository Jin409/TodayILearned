# 동시성 문제란

```java

@Service
public class StockService {

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void decrease(Long id, Long quantity) {
        Stock stock = stockRepository.findById(id).orElseThrow();
        stock.decrease(quantity);

        stockRepository.saveAndFlush(stock);
    }
}
```

만약, 고객이 100개의 재고가 있는 상품을 100개 주문하면 어떻게 될까? 남아 있는 재고는 0개가 되어야 할 것이다.
그러나 동시에 100명이 1개씩 상품을 주문한다면 어떻게 될까?

![동시성-문제-발생-원인](https://github.com/Jin409/TodayILearned/assets/77621712/4ae7bc20-c145-4fbc-987b-cefa34761d41)

우리가 예상하는 상황은 위와 같다. 쓰레드 1이 갱신된 이후에 쓰레드 2가 접근하여 갱신하는 것이다.
쓰레드 1이 재고를 1개 줄여 4개가 되고, 그 이후에 쓰레드 2가 접근하여 4를 3으로 줄이는 것이다.

그러나 실제는 다음과 같다.

![동시성-문제-발생-원인-2](https://github.com/Jin409/TodayILearned/assets/77621712/c6322818-94ee-4b50-8b1b-d3dd213d0ff3)

위처럼 쓰레드 1이 커밋을 하기 전에 쓰레드 2가 접근하여 최종적으로 두 번의 재고를 줄였으나 1번만 줄어든 4가 되는 것이다.

이러한 문제는 두개 이상의 쓰레드가 공유 데이터에 액세스를 할 수 있고, 동시에 변경을 하고자 할 때 발생하는 문제이며, `race condition` 이라고 한다.

# 해결 방법

## synchronized

이는 자바에서 지원하는 방법이다.
이는 하나의 쓰레드가 메서드를 실행하고 있는 경우에 다른 쓰레드들은 접근하지 못하도록 하는 것이다.

```java

@Service
public class StockService {
    @Transactional
    public synchronized void decrease(Long id, Long quantity) {
        Stock stock = stockRepository.findById(id).orElseThrow();
        stock.decrease(quantity);

        stockRepository.saveAndFlush(stock);
    }
}
```

### 문제점 1. @Transactional 과 함께 사용할 수 없다.

자바의 synchronized 는 @Transactional 어노테이션과 함께 사용할 수 없다.
스프링부트의 Transactional 어노테이션은 AOP 이기 때문에 프록시 객체가 생성되어 동작한다.
프록시 객체는 기존의 객체에서 메서드의 시그니처들을 가져오게 되는데, synchornized 는 시그니처가 아니기 때문에 이 과정에서 누락된다.
따라서 쓰레드 하나만이 해당 메서드에 접근한다는 보장을 줄 수 없게 되는 것이다.

### 문제점 2. 하나의 프로세스 안에서만 보장이 된다.

대부분의 실무에서의 서비스들은 여러 대의 서버를 활용하여 동작한다.
서버가 한 대인 경우에는 데이터의 접근을 한 대만 하기 때문에 문제가 없지만, 두대 이상인 경우에는 결국 데이터에 대한 접근을 여러 군데에서 할 수 있게 된다.
따라서 이는 동시성 문제에 적절한 해결 방안이 아니다.