# 다형적 참조

- 다형적 참조는 여러 클래스들을 하나로 묶을 수 있다.
    - ex) Cat, Caw, Camel 등을 하나의 카테고리로 묶을 수 있다.
    - Animal 이라는 상위의 클래스를 만들어, Cat, Caw, Camel 이 상속받거나 / 구현하도록 하면 된다.

# 추상 클래스

- 실제 생성되면 안되는 클래스
- 실체인 인스턴스가 존재하지 않고, 상속을 목적으로 사용한다.
    - ex) Animal 과 같이 생성되어서는 안되는 경우

```java
abstract class Example {

}
```

## 추상 메서드

- 자식 클래스가 반드시 오버라이딩 해야 하는 메서드
- 추상적인 개념을 제공하는 메서드

```java
abstract class Example {
    public abstract void sound();
}
```

- 추상 메서드가 하나라도 존재하는 클래스는 추상 클래스로 선언되어야 한다.
- 추상 메서드는 상속 받는 클래스가 반드시 오버라이딩 해서 사용해야 한다.
    - 이로 인해서 추상 메서드는 바디가 없다.

## 추상 클래스의 추상 메서드가 아닌 메서드

```java
abstract class Example {
    public abstract void sound();

    public void move() {
        // .. 
    }
}
```

- sound 메서드는 반드시 자식 클래스에서 오버라이딩 해야 하지만, move 는 단순히 상속을 위한 메서드이다.

## 추상 클래스의 추상 메서드 호출 시

![추상-메서드](https://github.com/Jin409/TodayILearned/assets/77621712/832dc48f-b17a-4bca-8ee2-2e3636f3003c)

- 오버라이딩된 메서드가 우선이기 때문에, sound 메서드는 자식 클래스에서 찾아서 호출한다.

## 순수 추상 클래스

- 추상 메서드만 갖고 있는 클래스

### 특징

- 인스턴스를 생성할 수 없다.
- 자식은 모든 메서드를 오버라이딩해야 한다.
- 이는 주로 다형성을 위해 사용된다.
    - 부모 클래스로부터 무언가를 상속받지 않기 때문이다.

=> 이는 인터페이스 같지 않나?!
<br>

- USB 의 인터페이스를 생각해보면, 해당 규격에 맞게 기기를 개발을 해야만 연결이 된다.
    - USB 인터페이스는 분명한 규격이 있다.
    - 연결된 장치들은 이를 맞춰서 개발해야 연결이 된다.
    - USB 인터페이스는 마치 추상 클래스 같고, 연결되는 기기들은 마치 자식 클래스같다.

# 인터페이스

- 자바에서는 순수 추상 클래스가 아닌 인터페이스를 사용한다.

```java
public interface Example {
    void sound();

    void move();
}
```

## 순수 추상 클래스와의 차이

- `public abstract` 를 생략할 수 있다.
    - 이가 생략되어 있는 것이다.
- 다중 구현을 지원한다.

## 인터페이스의 멤버 변수

```java
 public interface InterfaceAnimal {
    public static final int MY_PI = 3.14;
}
```

- 위처럼 굳이 public static final 을 붙이지 않아도, 상수인 것으로 간주한다.
- 인터페이스는 상속의 개념이 아니라 `구현`이다.
    - 클래스의 경우에는 멤버 변수를 상속 받은 자식 객체들이 사용하지만, 인터페이스는 상속의 개념이 아니기 때문에 멤버 변수는 무조건 상수로 정의되는 것이다.

## 상속 vs 구현

- 인터페이스는 모든 메서드가 추상 메서드이다.
    - 따라서 상속 받는 것은 하나도 없고 자식 클래스에서 무조건 구현을 해야 한다.
- 그러나, 이에 대한 용어는 자바 입장에서는 똑같다.
    - 메모리 구조도 동일하다.

## 인터페이스를 사용해야 하는 이유

- 인터페이스를 구현하는 곳에서 이를 반드시 구현하라는 제약을 주는 것이다.
    - 강하게 이를 구현하는 자식 클래스에 규약을 준다.
- 순수 추상 클래스의 경우에는 추후에 해당 추상 클래스에 누군가가 구현된 메서드를 추가할 수 있다.
    - 이렇게 되는 경우, 더 이상 순수 추상 클래스가 아니게 되기 때문에 이러한 경우에는 인터페이스를 사용해야 하는 것이다.
    - 이렇게 되면, 어떤 자식 클래스에서는 해당 메서드를 오버라이드 하고, 어떤 클래스에서는 오버라이드 하지 않을 수도 있다.

## default

```java
public interface Example {
    default void method() {
        // 구현 가능..
    }
}
```

- 메서드에 default 를 키워드를 추가하면 인터페이스에서도 메서드 구현이 가능하다.

# 다중 구현

- 클래스에서는 다중 구현을 허용하지 않는데, 인터페이스는 어떻게 허용하게 된 것일까?

## 클래스에서 다중 구현을 허용하지 않는 이유

![다중-상속](https://github.com/Jin409/TodayILearned/assets/77621712/760a7566-8d49-4f54-acb8-16e9cb0c87bc)

- 클래스의 다중 상속은 어떤 부모 클래스의 메서드를 호출해야 할지 알 수 없다.
- 자식 클래스인 AirplaneCar 에서 move 메서드를 호출하면 두개의 부모 클래스 중, 어떤 클래스의 메서드를 호출해야 할지 알 수 없다.

## 인터페이스에서 다중 구현을 허용하는 이유

```java
public interface InterfaceA {

}

public interface InterfaceB {

}

public class Child implements InterfaceA, InterfaceB {

}
```

![인터페이스의-구현](https://github.com/Jin409/TodayILearned/assets/77621712/9dae1b50-dce3-419a-a42f-c73047256853)

- 인터페이스는 구현이 없다.
- 즉, 아무리 많은 인터페이스를 상속(구현)하게 되더라도 결국 자식 클래스에서 이를 구현하게 된다.
- 구현하는 인터페이스에 모두 겹치는 메서드가 있다고 하더라도, 결국 자식 클래스에 구현된 메서드를 호출한다.

![인터페이스의-구현-2](https://github.com/Jin409/TodayILearned/assets/77621712/b63f09ed-fc5d-4521-bf63-a4a087f290e2)
![인터페이스의-구현-3](https://github.com/Jin409/TodayILearned/assets/77621712/58b8d06c-f10a-413f-bd4a-e46cb173dfc0)

- 메모리의 구조는 위와 같다.
    - InterfaceA 에서 메서드를 호출하면 구현된 메서드를 찾아 호출한다.
    - InterfaceB 에서 메서드를 호출해도 자식 클래스에서 구현된 메서드를 찾아 호출한다.
