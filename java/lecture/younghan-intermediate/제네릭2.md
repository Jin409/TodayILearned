# 타입 매개변수를 적용하지 않은 경우

```java
public class DogHospital {
    private Dog animal;

    public void set(Dog animal) {
        this.animal = animal;
    }

    public void checkUp() {
        System.out.println("동물 이름 : " + animal.getName());
        System.out.println("동물 크기 : " + animal.getSize());
        animal.sound();
    }

    public Dog bigger(Dog target) {
        // 더 큰 것을 반환해준다
        return animal.getSize() > target.getSize() ? animal : target;
    }
}

public class CatHospital {
    private Cat animal;

    public void set(Cat animal) {
        this.animal = animal;
    }

    public void checkUp() {
        System.out.println("동물 이름 : " + animal.getName());
        System.out.println("동물 크기 : " + animal.getSize());
        animal.sound();
    }

    public Cat bigger(Cat target) {
        // 더 큰 것을 반환해준다
        return animal.getSize() > target.getSize() ? animal : target;
    }

}

public static void main(String[] args) {
    DogHospital dogHospital = new DogHospital();
    CatHospital catHospital = new CatHospital();

    Dog dog = new Dog("멍멍이1", 100);
    Cat cat = new Cat("냐옹이1", 300);

    // 개 병원
    dogHospital.set(dog);
    dogHospital.checkUp();

    catHospital.set(cat);
    catHospital.checkUp();

    // 문제1. 개 병원에 고양이를 전달하게 되면?
    // dogHospital.set(cat); 컴파일 오류가 발생한다

    // 문제 2. 개 타입 반환
    dogHospital.set(dog);
    Dog diggerDog = dogHospital.bigger(new Dog("멍멍이2", 200));
    System.out.println("diggerDog = " + diggerDog); // Dog 타입을 잘 반환한다
}
```

- 위와 같이 각각 고양이, 강아지가 들어갈 수 있는 병원에 대해 정의한다고 가정해보자.
- 개 병원에 고양이를 넣을 수 없고 (컴파일 에러 발생), 개 타입만을 반환한다.
    - 이는 타입 안정성을 지켜준다.
- 그러나, 고양이/강아지 병원에 대한 코드가 거의 유사하다.
    - 코드의 재사용성이 떨어진다.

## 다형성 시도

- Cat, Dog 는 모두 Animal 이라는 부모 클래스를 갖고 있다.

```java
public class AnimalHospitalV1 {
    private Animal animal;

    public void set(Animal animal) {
        this.animal = animal;
    }

    public void checkUp() {
        System.out.println("동물 이름 : " + animal.getName());
        System.out.println("동물 크기 : " + animal.getSize());
        animal.sound();
    }

    public Animal bigger(Animal target) {
        // 더 큰 것을 반환해준다
        return animal.getSize() > target.getSize() ? animal : target;
    }
}

public static void main(String[] args) {
    AnimalHospitalV1 dogHospital = new AnimalHospitalV1();
    AnimalHospitalV1 catHospital = new AnimalHospitalV1();

    Dog dog = new Dog("멍멍이1", 100);
    Cat cat = new Cat("냐옹이1", 300);

    // 개 병원
    dogHospital.set(dog);
    dogHospital.checkUp();

    catHospital.set(cat);
    catHospital.checkUp();

    // 문제1. 개 병원에 고양이를 전달하게 되면?
    dogHospital.set(cat); // 매개변수에서의 타입 안정성이 지켜지지 않음

    // 문제 2. 개 타입 반환
    dogHospital.set(dog);
    // animal 로 반환된다. -> 캐스팅이 필요하다
    // Dog diggerDog = dogHospital.bigger(new Dog("멍멍이2", 200));
    Dog biggerDog = (Dog) dogHospital.bigger(new Dog("멍멍이2", 200));
    System.out.println("diggerDog = " + biggerDog); // Dog 타입을 잘 반환한다
}
```

- 이는 부모 클래스를 이용해 코드의 중복은 줄였다.
- 그러나 타입 안정성을 지키지 못했다.
    - 매개변수로 들어오는 타입을 지정하지 못한다. (DogHospital 에 고양이를 넣을 수 있다)
    - 반환타입을 알 수가 없다. (상위 타입인 Animal 로 반환된다)

## 제네릭 도입

```java
public class AnimalHospitalV2<T> {
    private T animal;

    public void set(T animal) {
        this.animal = animal;
    }

    public void checkUp() {
        System.out.println("동물 이름 : " + animal.getName());
        System.out.println("동물 크기 : " + animal.getSize());
        animal.sound();
    }

    public T bigger(T target) {
        // 더 큰 것을 반환해준다
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```

- 컴파일 시점에는 T 의 타입을 알 수가 없다
    - 이로 인해서 animal.getName(), animal.getSize() 와 같은 메서드를 호출할 수가 없다.

```java
public void main() {
    AnimalHospitalV2<Integer> integerHospital = new AnimalHospitalV2<>();
    AnimalHospitalV2<Object> objectHospital = new AnimalHospitalV2<>();
}
```

- 제네릭을 사용했기 때문에 Animal 이 아닌 타입들도 모두 들어올 수 있다.
    - 이상하다! 우리는 동물병원에 대해 정의한 것인데 의도하지 않은 타입들도 모두 들어올 수 있게 된 것이다.

# 타입 매개변수 제한

```java
public class AnimalHospitalV3<T extends Animal> {
    private T animal;

    public void set(T animal) {
        this.animal = animal;
    }

    public void checkUp() {
        System.out.println("동물 이름 : " + animal.getName());
        System.out.println("동물 크기 : " + animal.getSize());
        animal.sound();
    }

    public T bigger(T target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```

- `T extends Animal` 로 인해서 T 의 상한을 Animal 로 정의한다.
    - 적어도 Animal 타입에 속한 메서드와 속성들은 모두 사용할 수 있다.

```java
 public static void main(String[] args) {
    AnimalHospitalV3<Dog> dogHospital = new AnimalHospitalV3();
    AnimalHospitalV3<Cat> catHospital = new AnimalHospitalV3();

    // 문제 1. 개 병원에 고양이를 전달하는 경우
    // dogHospital.set(new Cat("냥이", 100)); 컴파일 오류가 발생한다.

    // 문제 2. 반환 타입
    dogHospital.set(new Dog("멍이1", 100));
    // 캐스팅할 필요가 없다.
    Dog biggerDog = dogHospital.bigger(new Dog("멍이2", 20));
}
```

- 위와 같이 타입을 정의하면, Dog 와 Cat 타입이 Animal 을 extends 하고 있는지 (자식 타입인지) 확인한다.
    - 상속하고 있지 않은 경우에는 컴파일 오류를 발생시킨다.
- 타입 안정성을 보장한다.
    - 개 병원에 고양이를 전달하는 경우에는 컴파일 오류가 난다.
    - 반환 타입이 명시된다.

# 기존 문제와 해결

## 타입 안정성의 문제

- 개 병원에 고양이를 전달하는 문제 -> 해결
- Animal 타입을 반환하기 때문에 다운 캐스팅을 해야 한다. -> 해결
- 실수로 고양이를 입력했는데, 개를 반환하는 상황이면 캐스팅 예외가 발생한다 -> 해결

## 제네릭 도입의 문제

- 제네릭에서 타입 매개변수를 사용하면 어떤 타입이든 들어올 수 있다. -> 해결
- Object 의 기능한 사용할 수 있다. (Animal 클래스 내부의 메서드 사용 못하는 문제) -> 해결
    - Animal 이 상한이 되어서 Animal 이 기능은 모두 사용할 수 있다.
